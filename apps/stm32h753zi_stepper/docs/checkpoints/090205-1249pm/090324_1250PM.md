## Decisions

- Persistence strategy
  - Primary attempt: Zephyr Settings/NVS on `storage_partition`; accept failure on STM32H7 due to 128 KiB erase size.
  - Secondary: LittleFS on the board’s fixed `storage` partition using Zephyr FS + FMP.
  - Tertiary: Append-only flash KV fallback aligned to 32-byte write-block size.

- Partitioning fix for LittleFS
  - Use an app-local DTS overlay to enlarge `storage` to 256 KiB (two 128 KiB erase units), enabling LittleFS format/mount without hardware changes.

- Build/test scope
  - Focus on persist for persistence validation; defer unrelated full-app build issues.
  - Keep runtime fallbacks and detailed logging.

- UX/bring-up safety
  - Keep VMOT off during early validation.
  - Map USER button (B1) to cold reset to speed iteration.

- Code hygiene
  - Change `main` signature to `int main(void)` and return `0` on all paths.

## Code Snippets

- LittleFS mount helper (Zephyr FS API)  
  File: main.c
  ```c
  FS_LITTLEFS_DECLARE_DEFAULT_CONFIG(lfs_storage);
  static struct fs_mount_t lfs_mnt = {
    .type = FS_LITTLEFS, .mnt_point = "/lfs",
    .fs_data = &lfs_storage,
    .storage_dev = (void *)FIXED_PARTITION_ID(storage_partition),
  };
  static bool lfs_mounted;
  static int lfs_mount_if_needed(void) {
    if (lfs_mounted) return 0;
    int rc = fs_mount(&lfs_mnt);
    if (!rc) lfs_mounted = true;
    return rc;
  }
  ```

- Flash KV fallback (append-only, 32-byte slots)
  ```c
  #define KV_SLOT_SIZE 32
  static int kv_store_write(uint8_t key, uint8_t val) { /* scan->append->erase if full */ }
  static int kv_store_read(uint8_t key, uint8_t *val) { /* scan latest by seq */ }
  ```

- USER button (B1) → cold reset  
  File: main.c
  ```c
  #include <zephyr/drivers/gpio.h>
  #include <zephyr/sys/reboot.h>

  #if DT_NODE_EXISTS(DT_ALIAS(sw0)) && DT_NODE_HAS_PROP(DT_ALIAS(sw0), gpios)
  {
    const struct gpio_dt_spec user_btn = GPIO_DT_SPEC_GET_OR(DT_ALIAS(sw0), gpios, {0});
    if (device_is_ready(user_btn.port)) {
      gpio_pin_configure_dt(&user_btn, GPIO_INPUT);
      static struct gpio_callback user_cb;
      void user_button_pressed(const struct device *dev, struct gpio_callback *cb, uint32_t pins) {
        sys_reboot(SYS_REBOOT_COLD);
      }
      gpio_init_callback(&user_cb, user_button_pressed, BIT(user_btn.pin));
      gpio_add_callback(user_btn.port, &user_cb);
      gpio_pin_interrupt_configure_dt(&user_btn, GPIO_INT_EDGE_TO_ACTIVE);
    }
  }
  #endif
  ```

- DTS overlay to enlarge storage to 256 KiB  
  File: nucleo_h753zi.overlay
  ```dts
  &flash0 {
    partitions {
      storage_partition: partition@20000 {
        reg = <0x00020000 0x00040000>;
        label = "storage";
      };
    };
  };
  ```

## Open Questions

- Persistence integration
  - Keep LittleFS as the permanent persistence backend on this board, or pursue NVS alternatives in future (e.g., different partitioning or NVS adaptations)?
  - Should we preformat LittleFS or always auto-format on first boot?

- Scope of overlay
  - Apply the `storage` re-size overlay to the full app as well, or keep it limited to the smoke tests?

- Testing
  - Add native_sim/native_posix tests to exercise the persistence layer (mock FS + read/write/retention) and a small harness for LFS?

- Tooling/noise
  - OpenOCD STM32H7 “read_memory” init warnings: acceptable to ignore, or switch runner (e.g., STM32CubeProgrammer) for cleaner logs?

- App-wide button behavior
  - Promote B1→reset behavior to the main app, or keep it just in smoke samples?

## Next Steps

- Commit current changes
  - Commit main.c fixes (int main + returns, USER button reset) and the `nucleo_h753zi.overlay` enlargement for `storage`.

- Propagate persistence
  - Wire the LittleFS-backed persistence into the main `stm32h753zi_stepper` app once its unrelated build issues are addressed.
  - Optionally, gate auto-format with a sentinel to avoid reformatting if FS is present.

- Add tests
  - Create a minimal native_sim test under tests to verify FS mount, read/write, and retention across simulated restarts.

- Operational polish
  - Add a small CLI (shell cmd) to print persistence status (backend used, file size, last value).
  - Document the overlay decision in STATUS.md with rationale and steps to adjust.

- Optional
  - Evaluate switching flash runner to reduce OpenOCD init warnings.
  - Add a debounce/timer guard for the B1 reset callback if needed in the main app.

Anchors and timestamps
- [A1 • 2025-09-03 11:20] Built smoke/persist; initial NVS fail, LFS fail (single block), KV fallback succeeded.
- [A2 • 2025-09-03 12:05] Implemented LFS helpers, tuned Kconfig (read/prog/cache 32, lookahead 8).
- [A3 • 2025-09-03 12:15] Enlarged `storage` via overlay to 256 KiB; rebuild succeeded.
- [A4 • 2025-09-03 12:30–12:40] Flashed; serial logs show: NVS -22; LittleFS mounts with “2 0x20000-byte blocks”; read/write OK; B1 reset confirmed.